<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2017 v5.4.139
     Generated on:       5/9/2017 4:10 PM
     Generated by:       Matthew Oestreich
     Organization:       Matthew Oestreich
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2017
#>


function Get-ConfigPaths
{
            <#
                    .SYNOPSIS
                    Get-ConfigPaths

                    .DESCRIPTION
                    Retrieves UNC paths to config.xml. 	
			
                    .PARAMETER ReturnPdcAndDfsPaths
                    Retrieves *ONLY* the UNC paths to DFS and PDC locations (defaults)
			
                    .EXAMPLE
                    C:\PS> Get-ConfigPaths
            #>	
	
	PARAM (
		
		[Parameter(Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[PsCredential]$GCP_PsCredentialObject,
		
		[Parameter(Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[string]$DomainName,
		
		[Parameter(Mandatory = $false)]
		[switch]$ReturnPdcAndDfsPaths
		
	)
	
	try
	{
		$NIAMOD = (Get-ADSIDomain -Credential $GCP_PsCredentialObject -DomainName $DomainName)
		$PDC = $NIAMOD.Forest.RootDomain.PdcRoleOwner.Name
		$FRD = $NIAMOD.Forest.RootDomain.Name
		$PDC_P = "\\$PDC\NETLOGON\NewAdUserTool\config.xml"
		$FRD_P = "\\$FRD\NETLOGON\NewAdUserTool\config.xml"
		$Out = $null
		$customReturn = @{ }
		
		if (-not $ReturnPdcAndDfsPaths)
		{
			if (Test-Path $FRD_P)
			{
				[string]$customReturn.MainPath = (Import-Clixml $FRD_P).MainPath
				[string]$customReturn.BackupPath = (Import-Clixml $FRD_P).BackupPath
				
				$Out = $customReturn
			}
			
			if (-not (Test-Path $FRD_P)) # If we cant reach config.xml via DFS, we query the PDC
			{
				
				if (Test-Path $PDC_P)
				{
					[string]$customReturn.MainPath = (Import-Clixml $PDC_P).MainPath
					[string]$customReturn.BackupPath = (Import-Clixml $PDC_P).BackupPath
					
					$Out = $customReturn
				}
				
				if (-not (Test-Path $PDC_P)) # If we can't reach either DFS or PDC, return false values'
				{
					$customReturn.MainPath = $false
					$customReturn.BackupPath = $false
					
					$Out = $customReturn
				}
			}
		}
		
		if ($ReturnPdcAndDfsPaths)
		{
			$customReturn.MainPath = $FRD_P
			$customReturn.BackupPath = $PDC_P
			
			$Out = $customReturn
		}
		
		if ($Out)
		{
			return $Out
		}
	}
	catch
	{
		$_
	}
}

function Get-UserAccess
{
<#
	.SYNOPSIS
    Get-UserAccess

    .DESCRIPTION			
    Essentially grabs 'Required Access Groups' and verifies the supplied account is a member of either admin or user group	
    Returns a string of (based upon access):
    * 'isadmin'
    * 'isUser'
    * 'noAccess'
			
    .EXAMPLE
    C:\PS> Get-UserAccess -Validate_Username 'some.user' -Validate_Domain 'someDomain.local'
#>
	PARAM (
		[Parameter(Mandatory = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[string]$Validate_Username,
		
		[Parameter(Mandatory = $true, Position = 1)]
		[ValidateNotNullOrEmpty()]
		[string]$Validate_DomainName,
		
		[Parameter(Mandatory = $true, Position = 2)]
		[ValidateNotNullOrEmpty()]
		$ConfigObject
	)
	
	try
	{
		$rqG = $ConfigObject
		$rqA = $rqG.SecuritySettings.appAdmins
		$rqR = $rqG.SecuritySettings.appUsers
		$domName = $Validate_DomainName
		$User = $Validate_Username
		$adminGroup = @()
		$usersGroup = @()
		
		(Get-ADSIGroupMember -Identity $rqA -DomainName $domName -Credential $CredentialObject).samAccountName | ForEach-Object {
			$adminGroup += $_
		}
		(Get-ADSIGroupMember -Identity $rqR -DomainName $domName -Credential $CredentialObject).samAccountName | ForEach-Object {
			$usersGroup += $_
		}
		
		if ($adminGroup -contains $User)
		{
			#$TXT_TYPE_OF_ACCESS.Text = 'isAdmin'
			$return = 'isAdmin'
		}
		elseif (($adminGroup -notcontains $User) -and ($usersGroup -contains $User))
		{
			#$TXT_TYPE_OF_ACCESS.Text = 'isUser'
			$return = "isUser"
		}
		elseif (($adminGroup -contains $User) -and ($usersGroup -contains $User))
		{
			#$TXT_TYPE_OF_ACCESS.Text = 'isAdmin'
			$return = 'isAdmin'
		}
		elseif (($adminGroup -notcontains $User) -and ($usersGroup -notcontains $User))
		{
			$return = 'noAccess'
		}
		
		return $return
	}
	catch
	{
		$_
	}
}

function New-ConfigObject
{
            <#
                    .SYNOPSIS
                    Get-ConfigObject

                    .DESCRIPTION			
                    Retrieves config from config.xml @ specified locations. 	
			
                    .PARAMETER MainPath
                    Main path to config.xml
			
                    .PARAMETER BackupPath
                    Backup path to config.xml
			
                    .PARAMETER ReturnDefaultConfig
                    Instead of querying, and then returning config.xml, we return a pre-canned default config
			
                    .EXAMPLE
                    C:\PS> Get-ConfigObject -ReturnDefaultConfig
            #>
	
	PARAM (
		
		[Parameter(Mandatory = $false, Position = 0, ParameterSetName = 'MB')]
		[ValidateNotNullOrEmpty()]
		[string]$NCO_Path,
		
		[Parameter(Mandatory = $false, ParameterSetName = 'DFLT')]
		[switch]$ReturnDefaultConfig
		
	)
	
	try
	{
		if (-not $ReturnDefaultConfig)
		{
			$mp = $NCO_Path
			$theStuff = $null
			
			if (Test-Path $mp)
			{
				$theStuff = Import-Clixml $mp
			}
			
			if (-not (Test-Path $mp))
			{
				$theStuff = $false
			}
			
			Start-Sleep -Milliseconds 200
			
			if ($theStuff) { return $theStuff }
		}
		
		if ($ReturnDefaultConfig)
		{
			
			$DMC = New-Object System.Object
			$Sts = @()
			$Ttls = @()
			$Dptmts = @()
			$Dcptns = @()
			$ConfLoc = @()
			$bConfLoc = @()
			$Secrty = [pscustomobject]@{
				'appAdmins' = 'Domain Admins' 
				'appUsers' = 'Domain Users'
			}
			
			$DMC | Add-Member -MemberType NoteProperty -Name 'MainPath' -Value $ConfLoc
			$DMC | Add-Member -MemberType NoteProperty -Name 'BackupPath' -Value $bConfLoc
			$DMC | Add-Member -MemberType NoteProperty -Name 'SecuritySettings' -Value $Secrty
			$DMC | Add-Member -MemberType NoteProperty -Name 'Sites' -Value $Sts
			$DMC | Add-Member -MemberType NoteProperty -Name 'Titles' -Value $Ttls
			$DMC | Add-Member -MemberType NoteProperty -Name 'Departments' -Value $Dptmts
			$DMC | Add-Member -MemberType NoteProperty -Name 'Descriptions' -Value $Dcptns
			
			Start-Sleep -Milliseconds 250
			if ($DMC)
			{
				return $DMC
			}
		}
	}
	catch
	{
		$_
	}
	
}

function New-CredentialObject
{
            <#
                    .SYNOPSIS
                    New-CredentialObject

                    .DESCRIPTION
                    Retrieves PsCredential object of user input credentials	
			
                    .PARAMETER Username
                    The username, as string, that you would like as part of the PsCredential Object
			
                    .PARAMETER Password
                    Same as username, but for password.
			
                    .EXAMPLE
                    C:\PS> New-CredentialObject -Username "SomeUsername" -Password "S0m3p@55w0rd!" -Domain 'localdomain.local'
            #>	
	
	PARAM (
		
		[Parameter(Mandatory = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[string]$Username,
		
		[Parameter(Mandatory = $true, Position = 1)]
		[ValidateNotNullOrEmpty()]
		[string]$Password,
		
		[Parameter(Mandatory = $true, Position = 2)]
		[ValidateNotNullOrEmpty()]
		[string]$Domain
		
	)
	
	$un = "$Domain\$Username"
	$pw = $Password
	$spw = $pw | ConvertTo-SecureString -AsPlainText -Force
	
	$fobj = [pscredential]::new($un, $spw)
	
	if ($fobj) { return $fobj }
}

function Set-AccessView
{
<#
	.SYNOPSIS
	Set-AccessView

	.DESCRIPTION
	Enables/Disables particular controls based upon user access
	
	.PARAMETER TypeOfAccess
	Can only be 'isAdmin' or 'isUser'
			
	.EXAMPLE
    C:\PS> Test-Credentials -Context Domain -theUN some.user -thePW somePassword -DomainName somedomain.local
#>	
	PARAM (
		[Parameter(Mandatory = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[string]$TypeOfAccess
	)
	
	SWITCH ($TypeOfAccess)
	{
		{ $_ -eq 'isAdmin' } {
			# Do Nothing, default view is for admins	
		}
		
		{ $_ -eq 'isUser' } {
			$BTN_SETTINGS.Visible = $false
			$BTN_CHANGE_CONFIG_LOCATION.Visible = $false
		}
	}
}

function Set-ConfigObject
{
            <#
                    .SYNOPSIS
                    Set-ConfigObject

                    .DESCRIPTION			
                    Exports a user specified config object to user specified locations	
			
                    .PARAMETER ConfigObject
                    An object of the config you would like to save.
			
                    .PARAMETER PathToSave
                    Path where we should save the config							
			
                    .EXAMPLE
                    C:\PS> Set-ConfigObject -ConfigObject $C -PathToSave C:\Path\config.xml
            #>
	
	PARAM (
		
		[Parameter(Mandatory = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		$ConfigObject,
		
		[Parameter(Mandatory = $true, Position = 1)]
		[ValidateNotNullOrEmpty()]
		[string]$PathToSave
		
	)
	
	try
	{
		$ConfigObject | Export-Clixml -Path $PathToSave -Force
	}
	catch
	{
		$_
	}
	
}

function Test-Credentials
{
<#
	.SYNOPSIS
	Test-Credentials

	.DESCRIPTION
	Verifies Credentials, returns true/false
			
	.PARAMETER Context
	Authenticating at domain level or local level
			
	.PARAMETER theUN
	Username to verify
	
	.PARAMETER thePW
	Same as username, but for password.
	
	.PARAMETER DomainName
	Domain to verify user
			
	.EXAMPLE
    C:\PS> Test-Credentials -Context Domain -theUN some.user -thePW somePassword -DomainName somedomain.local
#>	
	[cmdletbinding()]
	PARAM (
		[PARAMETER(Mandatory = $true, Position = 0)]
		[ValidateSet('Domain', 'Local')]
		$Context,
		
		[PARAMETER(Mandatory = $true, Position = 1)]
		[string]$theUN,
		
		[PARAMETER(Mandatory = $true, Position = 2)]
		[string]$thePW,
		
		[PARAMETER(Mandatory = $false)]
		[string]$DomainName
	)
	
	SWITCH ($Context)
	{
		'Domain' {
			IF (!$DomainName)
			{
				$quitNow = $true
			}
			ELSE
			{
				$theContext = 'Domain'
				$Principal = $DomainName
			}
		}
		
		'Local' {
			$theContext = 'Machine'
			$Principal = $env:COMPUTERNAME
		}
	}
	
	IF ($quitNow -ne $true)
	{
		Add-Type -AssemblyName System.DirectoryServices.AccountManagement
		$DS = New-Object System.DirectoryServices.AccountManagement.PrincipalContext($theContext, $Principal)
		$DS.ValidateCredentials($theUN, $thePW)
	}
}


Export-ModuleMember -Function Get-ConfigPaths,
					Get-UserAccess,
					New-ConfigObject,
					New-CredentialObject,
					Set-AccessView,
					Set-ConfigObject,
					Test-Credentials